// ========================================================================
// Copyright (c) 2009-2010 Intalio, Inc.
// ------------------------------------------------------------------------
// All rights reserved. This program and the accompanying materials
// are made available under the terms of the Eclipse Public License v1.0
// and Apache License v2.0 which accompanies this distribution.
// The Eclipse Public License is available at 
// http://www.eclipse.org/legal/epl-v10.html
// The Apache License v2.0 is available at
// http://www.opensource.org/licenses/apache2.0.php
// You may elect to redistribute this code under either of these licenses. 
// ========================================================================
package org.eclipse.jetty.osgi.boot.internal.serverfactory;

import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import org.eclipse.jetty.osgi.boot.OSGiServerConstants;
import org.eclipse.jetty.server.Server;
import org.osgi.framework.Bundle;
import org.osgi.framework.ServiceEvent;
import org.osgi.framework.ServiceListener;
import org.osgi.framework.ServiceReference;

/**
 * Deploy the jetty server instances when they are registered as an OSGi service.
 */
public class JettyServerServiceTracker implements ServiceListener, IManagedJettyServerRegistry
{

    /**
     * Servers indexed by PIDs. PIDs are generated by the ConfigurationAdmin service.
     */
    private Map<String, ServerInstanceWrapper> _serversIndexedByName = new HashMap<String, ServerInstanceWrapper>();
    /** The context-handler to deactivate indexed by ServerInstanceWrapper */
    private Map<ServiceReference, ServerInstanceWrapper> _indexByServiceReference = new HashMap<ServiceReference, ServerInstanceWrapper>();
    

    /**
     * Stops each one of the registered servers.
     */
    public void stop()
    {
        //not sure that this is really useful but here we go.
    	for (ServerInstanceWrapper wrapper : _serversIndexedByName.values())
    	{
    		try
    		{
    			wrapper.stop();
    		}
    		catch (Throwable t)
    		{
    			
    		}
    	}
    }

    
    /**
     * Receives notification that a service has had a lifecycle change.
     * 
     * @param ev
     *            The <code>ServiceEvent</code> object.
     */
    public void serviceChanged(ServiceEvent ev)
    {
        ServiceReference sr = ev.getServiceReference();
        switch (ev.getType())
        {
            case ServiceEvent.MODIFIED:
            case ServiceEvent.UNREGISTERING:
            {
            	ServerInstanceWrapper instance = unregisterInIndex(ev.getServiceReference());
                if (instance != null)
                {
                    try
                    {
                    	instance.stop();
                    }
                    catch (Exception e)
                    {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            }
            if (ev.getType() == ServiceEvent.UNREGISTERING)
            {
                break;
            }
            else
            {
                // modified, meaning: we reload it. now that we stopped it;
                // we can register it.
            }
            case ServiceEvent.REGISTERED:
            {
            	Bundle contributor = sr.getBundle();
            	Server server = (Server)contributor.getBundleContext().getService(sr);
            	ServerInstanceWrapper wrapper = registerInIndex(server, sr);
            	Properties props = new Properties();
            	for (String key : sr.getPropertyKeys())
            	{
            		Object value = sr.getProperty(key);
            		props.put(key, value);
            	}
            	wrapper.start(server, props);
            break;
            }
        }
    }

    private ServerInstanceWrapper registerInIndex(Server server, ServiceReference sr)
    {
        String name = (String)sr.getProperty(OSGiServerConstants.MANAGED_JETTY_SERVER_NAME);
        if (name == null)
        {
        	throw new IllegalArgumentException("The property " +
        			OSGiServerConstants.MANAGED_JETTY_SERVER_NAME + " is mandatory");
        }
        ServerInstanceWrapper wrapper = new ServerInstanceWrapper(name);
        _indexByServiceReference.put(sr,wrapper);
        _serversIndexedByName.put(name,wrapper);
        return wrapper;
    }

    /**
     * Returns the ContextHandler to stop.
     * 
     * @param reg
     * @return the ContextHandler to stop.
     */
    private ServerInstanceWrapper unregisterInIndex(ServiceReference sr)
    {
    	ServerInstanceWrapper handler = _indexByServiceReference.remove(sr);
        if (handler == null)
        {
            // a warning?
            return null;
        }
        String name = handler.getManagedServerName();
        if (name != null)
        {
            _serversIndexedByName.remove(name);
        }
        return handler;
    }

    /**
     * @param managedServerName The server name
     * @return the corresponding jetty server wrapped with its deployment properties.
     */
    public ServerInstanceWrapper getServerInstanceWrapper(String managedServerName)
    {
    	return _serversIndexedByName.get(managedServerName == null
    			? OSGiServerConstants.MANAGED_JETTY_SERVER_DEFAULT_NAME : managedServerName);
    }
    
    
}
